options {
  LOOKAHEAD = 2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(CA2_3)
package yapl.compiler;

import yapl.lib.CompilerMessage;
import yapl.impl.symboltable.SymbolTableImpl;
import yapl.interfaces.Symboltable;
import yapl.interfaces.SymbolKind;
import yapl.interfaces.Symbol;
import yapl.impl.symboltable.SymbolImpl;
import yapl.interfaces.CompilerError;

/** Simple brace matcher. */
public class CA2_3 {

  private static Symboltable symbolTable = new SymbolTableImpl();

  private static String programName = "unknownProgramName";

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {

    try {
        CA2_3 parser = new CA2_3(new java.io.FileInputStream(args[0]));
        parser.Program();
        CompilerMessage.printOK(programName);
    } catch (java.io.FileNotFoundException e) {
        System.out.println("JavaCC Parser:  File " + args[0] + " not found.");
        return;
    } catch (ParseException exception) {
        CompilerMessage.printError(exception, programName);
    } catch (TokenMgrError error) {
        CompilerMessage.printError(error, programName);
    } catch (YAPLException exception) {
        CompilerMessage.printError(exception, programName);
    }
  }

}

PARSER_END(CA2_3)

/* TOKEN */

SKIP:
{
   " " | "\n" | "\r" | "\t"
}

MORE :
{
  "/*" : IN_COMMENT
}

<IN_COMMENT>
SPECIAL_TOKEN :
{
  <COMMENT: "*/" > : DEFAULT
}

<IN_COMMENT>
MORE :
{
  < ~[] >
}

/* PRODUCTIONS */

void RelOp() :
{}
{
"<" | "<=" | ">=" | ">"
}

void EqualOp() :
{}
{
"==" | "!="
}

void AddOp() :
{}
{
"+" | "-"
}

void MulOp() :
{}
{
"*" | "/" | "%"
}

void Literal() :
{}
{
"True" | "False" | <NUMBER>
}

void Selector() throws YAPLException :
{}
{
( "[" Expr() "]" | "." <IDENT> ) [ Selector() ]
}

void ArrayLen() throws YAPLException:
{ Token arrayToken;}
{
    "#"
    arrayToken=<IDENT> {
     Symbol arraySymbol = symbolTable.lookup(arrayToken.image);
         if (arraySymbol == null) {
             throw new YAPLException(CompilerError.IdentNotDecl, arrayToken, null);
         }
         if (!arraySymbol.getKind().equals(SymbolKind.PARAMETER) &&
             !arraySymbol.getKind().equals(SymbolKind.VARIABLE)) {
             throw new YAPLException(CompilerError.SymbolIllegalUse, arrayToken, arraySymbol);
         }
    }
     [ Selector() ]
}

void PrimaryExpr() throws YAPLException :
{ Token exprToken;}
{
Literal() | "(" Expr()")" | ProcedureCall()
  |
  exprToken=<IDENT>{
    Symbol exprSymbol = symbolTable.lookup(exprToken.image);
    if (exprSymbol == null) {
        throw new YAPLException(CompilerError.IdentNotDecl, exprToken, null);
    }
    if (!exprSymbol.getKind().equals(SymbolKind.PARAMETER) &&
        !exprSymbol.getKind().equals(SymbolKind.VARIABLE) &&
        !exprSymbol.getKind().equals(SymbolKind.CONSTANT)) {
        throw new YAPLException(CompilerError.SymbolIllegalUse, exprToken, exprSymbol);
    }
  }
  [ Selector() ] | ArrayLen()
}

void UnaryExpr() throws YAPLException :
{}
{
[AddOp()] PrimaryExpr()
}

void MulExpr() throws YAPLException :
{}
{
UnaryExpr() ( MulOp() UnaryExpr() )*
}

void AddExpr() throws YAPLException :
{}
{
MulExpr() ( AddOp() MulExpr() )*
}

void RelExpr() throws YAPLException :
{}
{
AddExpr() [ RelOp() AddExpr() ]
}

void EqualExpr() throws YAPLException :
{}
{
RelExpr() [ EqualOp() RelExpr() ]
}

void CondAndExpr() throws YAPLException :
{}
{
EqualExpr() ( "And" EqualExpr() )*
}

void CreationExpr() throws YAPLException :
{}
{
"new" NonArrayType() ( "[" Expr() "]" )*
}

void Expr() throws YAPLException :
{}
{
CondAndExpr() ( "Or" CondAndExpr() )* | CreationExpr()
}


void ArgumentList() throws YAPLException :
{}
{
Expr() ( "," Expr() )*
}

void ProcedureCall() throws YAPLException :
{ Token procedureToken; }
{
    procedureToken=<IDENT>{
        Symbol symbol = symbolTable.lookup(procedureToken.image);
        if (symbol == null) {
            throw new YAPLException(CompilerError.IdentNotDecl, procedureToken, null);
        }

        if (!symbol.getKind().equals(SymbolKind.PROCEDURE)) {
            throw new YAPLException(CompilerError.SymbolIllegalUse, procedureToken, symbol);
        }

    }
     "(" [ ArgumentList() ] ")"

}

void Assignment() throws YAPLException:
{ Token lvalueToken; }
{
    lvalueToken=<IDENT>{
        Symbol lvalueSymbol = symbolTable.lookup(lvalueToken.image);
        if (lvalueSymbol == null) {
            throw new YAPLException(CompilerError.IdentNotDecl, lvalueToken, lvalueSymbol);
        }

        if (!lvalueSymbol.getKind().equals(SymbolKind.VARIABLE) &&
            !lvalueSymbol.getKind().equals(SymbolKind.PARAMETER)) {
            throw new YAPLException(CompilerError.SymbolIllegalUse, lvalueToken, lvalueSymbol);
        }
    }[ Selector() ] ":=" Expr()
}

void IfStatement() throws YAPLException :
{}
{
"If" Expr() "Then" StatementList() [ "Else" StatementList() ] "EndIf"
}

void WhileStatement() throws YAPLException :
{}
{
"While" Expr() "Do" StatementList() "EndWhile"
}

void ReturnStatement() throws YAPLException :
{}
{
"Return" [ Expr() ]
}

void WriteStatement() :
{}
{
"Write" <STRING>
}

void Statement() throws YAPLException :
{}
{
IfStatement() | WhileStatement() | ReturnStatement()
  | WriteStatement() | Assignment() | ProcedureCall() | Block()
}

void StatementList() throws YAPLException :
{}
{
( Statement() ";" )*
}

void Block() throws YAPLException :
{}
{
    {
        symbolTable.openScope(false);
    }
    [ Decl() ] "Begin" StatementList() "End"
    {
        symbolTable.closeScope();
    }
}

void NonArrayType() throws YAPLException :
{ Token typeToken;}
{
"int" | "bool" |

    typeToken=<IDENT>{
        Symbol symbol = symbolTable.lookup(typeToken.image);
        if (symbol == null) {
            throw new YAPLException(CompilerError.IdentNotDecl, typeToken, symbol);
        }
        if (!symbol.getKind().equals(SymbolKind.TYPENAME)) {
            throw new YAPLException(CompilerError.SymbolIllegalUse, typeToken, symbol);
        }
    }
}

void Type() throws YAPLException :
{}
{
NonArrayType() ( "[" "]" )*
}

void ReturnType() throws YAPLException :
{}
{
"void" | Type()
}
void ConstDecl() throws YAPLException :
{ Token constToken; }
{
  "Const"
  constToken=<IDENT>
  {
    Symbol symbol = symbolTable.lookup(constToken.image);
    if (symbolTable.containsIdentifierInCurrentScope(constToken.image)) {
        throw new YAPLException(CompilerError.SymbolExists, constToken, symbol);
    }
    Symbol constSymbol = new SymbolImpl(SymbolKind.CONSTANT, constToken.image);
    constSymbol.setReadonly(true);
    constSymbol.setReference(false);
    symbolTable.addSymbol(constSymbol);
  }
   "=" Literal() ";"
}

void VarDecl(SymbolKind kind) throws YAPLException :
{ Token varToken;}
{
   Type()
   varToken=<IDENT>{
     Symbol symbol = symbolTable.lookup(varToken.image);
     if (symbolTable.containsIdentifierInCurrentScope(varToken.image)) {
        throw new YAPLException(CompilerError.SymbolExists, varToken, symbol);
     }
     Symbol varSymbol = new SymbolImpl(kind, varToken.image);
     varSymbol.setReadonly(false);
     varSymbol.setReference(false);
     symbolTable.addSymbol(varSymbol);
   }
   ( "," varToken=<IDENT>{
            symbol = symbolTable.lookup(varToken.image);
             if (symbolTable.containsIdentifierInCurrentScope(varToken.image)) {
                throw new YAPLException(CompilerError.SymbolExists, varToken, symbol);
             }
            varSymbol = new SymbolImpl(kind, varToken.image);
            varSymbol.setReadonly(false);
            varSymbol.setReference(false);
            symbolTable.addSymbol(varSymbol);
        }
    )* ";"
}

void TypeDecl() throws YAPLException :
{ Token recordToken; }
{
 "Record"
 recordToken=<IDENT>{
    Symbol symbol = symbolTable.lookup(recordToken.image);
     if (symbolTable.containsIdentifierInCurrentScope(recordToken.image)) {
        throw new YAPLException(CompilerError.SymbolExists, recordToken, symbol);
     }
    Symbol recordSymbol = new SymbolImpl(SymbolKind.TYPENAME, recordToken.image);
    recordSymbol.setReadonly(false);
    recordSymbol.setReference(false);
    symbolTable.addSymbol(recordSymbol);
    symbolTable.openScope(false);
  }

  VarDecl(SymbolKind.FIELD) ( VarDecl(SymbolKind.FIELD) )*
  "EndRecord"{
     symbolTable.closeScope();
   }
   ";"
}
void Decl() throws YAPLException :
{}
{
     "Declare" ( ConstDecl() | VarDecl(SymbolKind.VARIABLE) | TypeDecl() )*
}
void FormalParam() throws YAPLException :
{
    Token identToken;
}
{
     Type()
     identToken=<IDENT> {
        Symbol symbol = symbolTable.lookup(identToken.image);
         if (symbolTable.containsIdentifierInCurrentScope(identToken.image)) {
             throw new YAPLException(CompilerError.SymbolExists, identToken, symbol);
         }

         symbol = new SymbolImpl(SymbolKind.PARAMETER, identToken.image);
         symbolTable.addSymbol(symbol);
     }
}
void FormalParamList() throws YAPLException :
{}
{
     FormalParam() ( "," FormalParam() )*
}
void Procedure() throws YAPLException :
{
    Token procedureNameStartToken;
    Token procedureNameEndToken;
    Symbol procedureStartSymbol;
}
{
     "Procedure"
     ReturnType()
     procedureNameStartToken=<IDENT>{
         Symbol symbol = symbolTable.lookup(procedureNameStartToken.image);
         if (symbolTable.containsIdentifierInCurrentScope(procedureNameStartToken.image)) {
             throw new YAPLException(CompilerError.SymbolExists, procedureNameStartToken, symbol);
         }

         procedureStartSymbol = new SymbolImpl(SymbolKind.PROCEDURE, procedureNameStartToken.image);
         symbolTable.addSymbol(procedureStartSymbol);
         symbolTable.openScope(true);

     }
     "(" [ FormalParamList() ] ")" Block()

     procedureNameEndToken=<IDENT>{

        if (procedureNameEndToken.image.compareTo(procedureNameStartToken.image) != 0) {
            throw new YAPLException(CompilerError.EndIdentMismatch, procedureNameEndToken, procedureStartSymbol);
        }

        symbolTable.closeScope();
     }";"
}
void Program() throws YAPLException :
{
    Token programNameStartToken;
    Token programNameEndToken;
    Symbol programNameStartSymbol;
}
{

     "Program"
     programNameStartToken=<IDENT>
     {
        CA2_3.programName=programNameStartToken.image;
        symbolTable.openScope(true);
        programNameStartSymbol = new SymbolImpl(SymbolKind.PROGRAM, programNameStartToken.image);
        symbolTable.addSymbol(programNameStartSymbol);
        symbolTable.openScope(true);
     }

     ( Decl() | Procedure() )* "Begin" StatementList() "End"

     programNameEndToken=<IDENT> {
        if (programNameEndToken.image.compareTo(programNameStartToken.image) != 0) {
            throw new YAPLException(CompilerError.EndIdentMismatch, programNameEndToken, programNameStartSymbol);
        }

        symbolTable.closeScope();
        symbolTable.closeScope();
     }"."
}


TOKEN:
{
    <STRING: "\"" ( " " | <LETTER> | <DIGIT> | <OTHERCHAR> )* "\""> |
    <IDENT: <LETTER> ( <LETTER> | <DIGIT> )*> |
    <NUMBER: <DIGIT> ( <DIGIT> )*> |
    <#LETTER: "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P"
    | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f"
    | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v"
    | "w" | "x" | "y" | "z" | "_"> |
    <#DIGIT:  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"> |
    <OTHERCHAR: "+" |"-" | "*" | "/" | "." | "," | ";" | ":" | "!" |
        "?" | "="  | "#" | "%" | "<" | ">" | "$" | "(" | ")"
        | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}